JSON 支持 null 而不支持 undefined,序列化会剔除值为 undefined 的属性。
闭包是指一个函数有权访问定义在外部作用域中的任何变量。

类型安全是借助类型避免程序做无效的事情，如在对象调用不存在的方法、导入已被移除的模块等。

类型检查器检查代码是否符合类型安全的特殊程序。
TS 编译器生成 AST 后会执行类型检查器对 TS 代码做类型检查保证程序能够按预期正常运行，没有显而易见的错误。但是生成 JS 代码时，不会考虑类型，从而确保改动、更新和改进程序中的类型，无需担心会破坏应用的功能。

类型系统 类型检查器为程序分配类型时使用的一系列规则。类型系统主要有两种：显示注解类型和自动类型推导。

TS vs JS

| 类型系统特性       | JS     | TS     |
| :----------------- | ------ | ------ |
| 类型是如何绑定的？ | 动态   | 静态   |
| 是否自动类型转换？ | 是     | 否     |
| 何时检查类型？     | 运行时 | 编译时 |
| 何时报告错误？     | 运行时 | 编译时 |

```bash
yarn add --dev @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint typescript

yarn tsc --init
yarn eslint --init
```

类型 一系列值及其对其执行的操作。

- any 兜底类型，可忽略类型检查。无法确定类型时默认为`any`。尽量避免使用 包含所有类型，对其可以执行任意操作。编译选项`noImplicitAny`或`strict`启用将遇到隐式推导 any 类型会报错。
- unknown 表示一个无法预知的类型，可以表示任意值，但 ts 会要求做类型检查，细化类型，必须要显式注解。可以做比较(==、===、||、&&和?)、否定(!)以及 typeof 和 instanceof 运算细化。
- boolean 可执行比较、否定操作
- number 支持算术运算、比较运算
- bigint 支持算术运算、比较运算
- string
- symbol 使用 const 声明的符号，ts 会将其推导为 unique symbol 类型，unique symbol 类型的值始终与自身相等。

结构化类型 只关心对象有哪些属性，而不管属性使用了什么名称(名义化类型)。

类型字面量 仅表示一个值的类型 将类型设置为某个值从而限制只能取指定的值。
const 声明的基本类型的值，赋值后无法修改，ts 会将其推导出最窄的类型。

object 对值知之甚少，只能表示值是一个不为 null 的对象。
使用 const 声明对象不会导致 ts 把推导类型缩窄。应为对象类型的字段值是可变的。

默认情况下，ts 对对象属性要求十分严格，缺少或多了属性都会报错。

索引签名 [key: T]: U 可以指定对象添加更多的键，但键的类型比须赋给 number 或 string。

空对象类型({}) 除了 null 和 undefined 之外的任何类型都可以赋值给空对象类型，应尽量避免使用。

声明对象的四种方式

1. 对象字面表示法
2. 空对象字面量表示法({})
3. object 类型 需要一个对象，对字段没有要求
4. Object 类型

| 值              | {}  | object | Object |
| --------------- | --- | ------ | ------ |
| {}              | 是  | 是     | 是     |
| ['a']           | 是  | 是     | 是     |
| function() {}   | 是  | 是     | 是     |
| new String(''a) | 是  | 是     | 是     |
| 'a'             | 是  | 否     | 是     |
| Symbol('a')]    | 是  | 否     | 是     |
| 1               | 是  | 否     | 是     |
| null            | 否  | 否     | 否     |
| undefined       | 否  | 否     | 否     |

类型操作

类型别名 type TS 无法推导类型别名，必须显式注解。使用类型别名的地方可以换成源类型。类型别名采用块级作用域。同一作用域内不能重复定义。

并集 ｜
一个并集类型的值不一定属性并集中的某一个成员，还可以同时属于每个成员。
交集 &

并集较交集更符合常理，常用于混合类数组。

数组类型注解 T[]或 Array<T>

元组 数组类型的字类型，长度固定，各索引位上的值具有固定已知的类型，必须显式注解。

只读数组 使用 readonly 修饰符 或 Readonly 或 ReadonlyArray 句法。

undefined 未定义或未赋值
null 缺少值
void 函数没有显示返回任何值
never 函数根本不返回(如抛出异常、永远运行下去)

unknown 是任意类型的父类型，never 是任意类型的子类型。null 是除 never 之外的所有类型的子类型。每个类型的值都可能为 null。启用编译选项`strictNullChecks`可以对 是否处理 null 进行检查。

枚举 列举类型中的各个值。将键映射到值上。键固定的对象，访问键时，ts 将检查指定键是否存在。枚举主要分：字符串到字符串的映射和字符串到数值的映射两种。
ts 可以自动为枚举中的各个成员推导对应的数字，也可以手动指定。一个枚举可以分几次声明，但分开声明只能推导出部分值。枚举值既可通过值访问，也可通过键访问(不安全)。

const enum 不允许反向查找，默认不生产 js 代码，而是在用到枚举成员的地方内插对应的值（应尽量避免）。启用编译选项`preserveConstEnums`可以为 const enum 生成代码。
枚举中的数值可能置枚举于不安全的境地，最好使用字符串到字符串的映射或者不用。
